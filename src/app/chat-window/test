import { ChatService, ChatThread } from './../services/chat-service';
import { Component, ElementRef, inject, OnInit, ViewChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatIconModule } from '@angular/material/icon';
import { FormsModule } from '@angular/forms';
import { PickerComponent } from '@ctrl/ngx-emoji-mart';
import { map, Observable } from 'rxjs';


interface Message {
  text: string;
  sender: 'me' | 'other';
  showMenu?: boolean;
  menuOpen?: boolean;
  showReactions?: boolean;
  reaction?: string;
  type?: string;
  time?: string;
  isEditing?: boolean;
  msgId?: string;

}


@Component({
  selector: 'app-chat-window',
  standalone: true,
  imports: [CommonModule, MatIconModule, FormsModule, PickerComponent],
  templateUrl: './chat-window.html',
  styleUrls: ['./chat-window.scss'],
})
export class ChatWindowcomponent implements OnInit {
  @ViewChild('fileInput') fileInput!: ElementRef<HTMLInputElement>;

  private ChatService = inject(ChatService);
  private OutgoingMessages: ChatThread[] = [];
  private SelectedUserId = this.ChatService.SelectedUserId
  private selectedChatMessages: any[] = [];
  private myMessages$ !: Observable<ChatThread[]>
  public messages: ChatThread[] = []




  ngOnInit(): void {
    this.ChatService
      .GetUserOutgoingMessages(10, 1)
      .subscribe((messages) => {
        console.log(messages);
        this.OutgoingMessages = [...messages.data]
        this.myMessages$ = this.SelectedUserId.pipe(
          map((userId) =>
            userId ? this.OutgoingMessages.filter((c) => c.userId === userId).map((c) => { return { ...c, sender: 'You' } }) : []
          )
        );
        let updatedMessages: ChatThread[] = [];
        this.ChatService.getUserChatsById().subscribe((messages: ChatThread[]) => {
          this.selectedChatMessages = [...messages];
          updatedMessages = this.selectedChatMessages.map((c) => { return { ...c, sender: c.fromUser.firstName + ' ' + c.fromUser.lastName } });
          // Move the subscription to myMessages$ here to ensure updatedMessages is set
          this.myMessages$.subscribe((messages) => {
            console.log("hhh", messages);
            // this.messages = [...messages, ...updatedMessages];
            // console.log(this.messages);
          });
        });
      })
  }




  messageInput: string = '';
  showEmojiPicker: boolean = false;
  showAttachmentMenu: boolean = false;


  // Emoji
  toggleEmojiPicker() {
    this.showEmojiPicker = !this.showEmojiPicker;
  }
  addEmoji(event: any) {
    this.messageInput += event.emoji.native;
    this.showEmojiPicker = false;

    console.log(event);
  }

  // Send Message
  sendMessage() {
  if (this.messageInput.trim()) {
    const payload = {
      userId: this.SelectedUserId.value ?? 694,
      body: this.messageInput,
      voiceFileId: null,
      attachmentId: null,
      groupId: null,
      messageCode: new Date().getTime().toString()
    };

    this.ChatService.sendNewMessage(payload).subscribe({
      next: (res: any) => {
        console.log('Message sent:', res);

        const newMsg: ChatThread = {
          userId: payload.userId,
          sender: 'You',
          name: 'You',
          photo: 'assets/imges/Ellipse 514.svg',
          body: this.messageInput,
          lastMessage: this.messageInput,
          messages: [{
            userId: payload.userId,
            body: this.messageInput,
            type: 'text',
            time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
            photo: 'assets/imges/Ellipse 514.svg',
          }],
          lastMessageTime: new Date(),
          unreadCount: 0,
          totalCount: 1,
          type: 'text',
          time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
        };

        this.messages = [...this.messages, newMsg];
        this.messageInput = '';
      },
      error: (err) => {
        console.error('Error sending message:', err);
        alert('Failed to send message');
      }
    });
  }
}



  // Attachments
  toggleAttachmentMenu() {
    this.showAttachmentMenu = !this.showAttachmentMenu;
  }
  triggerFileInput(type: string) {
    this.fileInput.nativeElement.accept = type;
    this.fileInput.nativeElement.click();
    this.showAttachmentMenu = false;
  }
  handleFileUpload(event: any) {
    const file = event.target.files[0];
    if (file) {
      const fileUrl = URL.createObjectURL(file);
      if (file.type.startsWith("image/")) {
        this.messages.push({
          userId: 694,
          sender: 'You',
          name: 'You',
          photo: 'assets/imges/Ellipse 514.svg',
          body: fileUrl,
          lastMessage: fileUrl,
          messages: [{
            userId: 694,
            body: fileUrl,
            type: 'image',
            time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
            photo: 'assets/imges/Ellipse 514.svg',
          }],
          lastMessageTime: new Date(),
          unreadCount: 0,
          totalCount: 1,
          type: 'image',
          time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
        });
      } else {
        this.messages.push({
          userId: 694,
          sender: 'You',
          name: 'You',
          photo: 'assets/imges/Ellipse 514.svg',
          body: file.name,
          lastMessage: file.name,
          messages: [{
            userId: 694,
            body: file.name,
            type: 'file',
            time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
            photo: 'assets/imges/Ellipse 514.svg',
          }],
          lastMessageTime: new Date(),
          unreadCount: 0,
          totalCount: 1,
          type: 'file',
          time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
        });
      }
    }
  }

  // Audio Recording
  mediaRecorder: any;
  audioChunks: any[] = [];
  isRecording: boolean = false;

  async startRecording() {
    try {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert("Microphone not supported in this browser");
        return;
      }
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      this.mediaRecorder = new MediaRecorder(stream);
      this.audioChunks = [];

      this.mediaRecorder.ondataavailable = (event: any) => {
        if (event.data.size > 0) {
          this.audioChunks.push(event.data);
        }
      };

      this.mediaRecorder.onstop = () => {
        const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
        const audioUrl = URL.createObjectURL(audioBlob);

        if (this.messages) {
          this.messages.push({
            userId: 694,
            sender: 'You',
            name: 'You',
            photo: 'assets/imges/Ellipse 514.svg',
            body: audioUrl,
            lastMessage: audioUrl,
            messages: [{
              userId: 694,
              body: audioUrl,
              type: 'audio',
              time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
              photo: 'assets/imges/Ellipse 514.svg',
            }],
            lastMessageTime: new Date(),
            unreadCount: 0,
            totalCount: 1,
            type: 'audio',
            time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
          });
        }
      };

      this.mediaRecorder.start();
      this.isRecording = false;
    } catch (err) {
      console.error('Error accessing microphone', err);
    }
  }

toggleRecording() {
  this.isRecording = !this.isRecording;
}

stopRecording() {
  this.isRecording = false;
}



 toggleMenu(msg: Message) {
    msg.menuOpen = !msg.menuOpen;
  }

  // Copy
  copyMessage(msg: Message) {
    navigator.clipboard.writeText(msg.text).then(() => {
      alert('Message copied!');
    });
    msg.menuOpen = false;
  }

  // Edit
  editMessage(msg: Message) {
    msg.isEditing = true;
    msg.menuOpen = false;
  }

  saveEdit(msg: Message) {
    msg.isEditing = false;
  }

  cancelEdit(msg: Message) {
    msg.isEditing = false;
  }

  // Delete
  deleteMessage(msg: Message) {
    this.messages = this.messages.filter(m => m.msgId !== msg.msgId);
  }


openReactions(msg: Message) {
    msg.showReactions = !msg.showReactions;
    msg.menuOpen = false;
  }

  setReaction(msg: Message, reaction: string) {
    msg.reaction = reaction;
    msg.showReactions = false;
  }

}
